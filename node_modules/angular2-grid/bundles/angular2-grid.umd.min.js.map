{"version":3,"sources":["null","ng://angular2-grid/helpers/NgGridHelpers.ts","ng://angular2-grid/components/NgGridPlaceholder.ts","ng://angular2-grid/directives/NgGrid.ts","ng://angular2-grid/directives/NgGridItem.ts","ng://angular2-grid/modules/NgGrid.module.ts"],"names":["__values","o","m","Symbol","iterator","i","call","next","length","value","done","sortItemsByPositionHorizontal","a","b","col","row","sortItemsByPositionVertical","NgGridPlaceholder","_ngEl","_renderer","this","prototype","registerGrid","ngGrid","_ngGrid","ngOnInit","setElementClass","nativeElement","autoStyle","setElementStyle","setSize","newSize","_size","_recalculateDimensions","setGridPosition","newPosition","_position","_recalculatePosition","setCascadeMode","cascade","_cascadeMode","_setDimensions","w","h","_setPosition","x","y","colWidth","marginLeft","marginRight","screenMargin","rowHeight","marginTop","marginBottom","Component","args","selector","template","ElementRef","Renderer","NgGrid","_differs","componentFactoryResolver","EventEmitter","CONST_DEFAULT_RESIZE_DIRECTIONS","Map","Set","CONST_DEFAULT_CONFIG","_defineListeners","Object","defineProperty","v","setConfig","_differ","find","_config","create","diff","ngOnDestroy","_destroyed","_disableListeners","generateItemUid","uid","replace","c","r","Math","random","toString","_items","has","config","maxColRowChanged","val","intVal","parseInt","setMargins","max","_autoResize","dragEnable","resizeEnable","_maxRows","_maxCols","_visibleRows","_visibleCols","minRows","minCols","minHeight","minWidth","_zoomOnDrag","_cascadeGrid","_fixToGrid","_maintainRatio","_preferNew","_limitToScreen","_centerToScreen","resizeDirections","_elementBasedDynamicRowHeight","_itemFixDirection","_collisionFixDirection","_allowOverlap","console","warn","_enableListeners","_getFixDirectionFromCascade","newMaxCols","_getContainerColumns","_getScreenMargin","_aspectRatio","_updatePositionsAfterMaxChange","_calculateColWidth","_calculateRowHeight","maxWidth","maxHeight","ceil","_updateRatio","forEach","item","_this","_removeFromGrid","recalculateSelf","_addToGrid","_updateSize","getItemPosition","itemId","get","getGridPosition","getItemSize","getSize","ngDoCheck","changes","_applyChanges","margins","enableDrag","disableDrag","enableResize","disableResize","addItem","ngItem","newPos","_fixGridPosition","set","triggerCascade","then","onCascadeEvent","_emitOnItemChange","removeItem","delete","updateItem","_cascadePromise","Promise","resolve","setTimeout","triggerResize","resizeEventHandler","e","newMaxColumns","mouseDownEventHandler","mousePos","_getMousePosition","_getItemFromPosition","resizeDirection","canResize","_resizeReady","_resizingItem","_resizeDirection","preventDefault","canDrag","_dragReady","itemPos","_draggingItem","getPosition","_posOffset","left","top","mouseUpEventHandler","isDragging","_dragStop","isResizing","_resizeStop","_cleanDrag","_cleanResize","mouseMoveEventHandler","_resizeStart","_dragStart","_drag","_resize","onMouseMove","pos","dims","_hasGridCollision","_isWithinBounds","maxCols","getBoundingClientRect","width","floor","min_cols","maxRows","height","window","innerHeight","min_rows","forEachAddedItem","record","key","currentValue","forEachChangedItem","forEachRemovedItem","startMoving","_createPlaceholder","zIndex","_lastZValue","onResizeStart","emit","onResizeStartEvent","onDragStart","onDragStartEvent","_zoomOut","_resetZoom","getSelection","empty","removeAllRanges","selection","newL","newT","gridPos","_calculateGridPosition","_fixPosToBoundsX","_isWithinBoundsY","_fixPosToBoundsY","_placeholderRef","instance","indexOf","_fixGridCollisions","setPosition","onDrag","onDragEvent","itemDims","getDimensions","endCorner","resizeTop","includes","resizeBottom","resizeLeft","newW","newH","newX","newY","calcSize","_calculateGridSize","itemSize","iGridPos","bottomRightCorner","targetPos","assign","_isWithinBoundsX","_fixSizeToBoundsX","_fixSizeToBoundsY","fixResize","setDimensions","onResize","onResizeEvent","stopMoving","onDragStopEvent","onDragStop","destroy","onResizeStopEvent","onResizeStop","sizex","round","sizey","positions","_getCollisions","some","returns","leftCol","rightCol","topRow","bottomRow","_itemsInGrid","itemLeftCol","itemRightCol","itemTopRow","itemBottomRow","push","collisions","collisions_1","tslib_1.__values","collisions_1_1","collision","newItemPos","Error","itemsInGrid","Array","from","sort","NgGridHelper.sortItemsByPositionVertical","lowestRowPerColumn","itemsInGrid_1","itemsInGrid_1_1","isFixed","lowestRowForItem","lowestRowForColumn","NgGridHelper.sortItemsByPositionHorizontal","lowestColumnPerRow","itemsInGrid_2","itemsInGrid_2_1","lowestColumnForItem","lowestOffsetColumn","maxRow","_getMaxRow","maxCol","_getMaxCol","fixLoop","itemsInPath","_getItemsInVerticalPath","nextRow","itemsInPath_1","itemsInPath_1_1","min","apply","map","_getItemsInHorizontalPath","nextCol","itemsInPath_2","itemsInPath_2_1","startColumn","startRow","allowExcessiveItems","_fixPosToBounds","_fixSizeToBounds","add","_curMaxCol","_curMaxRow","itemsRows","itemsCols","TouchEvent","touches","changedTouches","refPos","clientX","clientY","_getAbsoluteMousePosition","itemWidth","_getContainerRows","position","size","factory","resolveComponentFactory","componentRef","containerRef","createComponent","placeholder","itemOutput","filter","getEventOutput","onItemChange","element","_documentMousemove$","fromEvent","document","_documentMouseup$","_mousedown$","_mousemove$","_mouseup$","_touchstart$","_touchmove$","_touchend$","_enabledListener","_enableMouseListeners","_isTouchDevice","_enableTouchListeners","_subscriptions","subs","unsubscribe","navigator","maxTouchPoints","touchstartSubs","subscribe","touchmoveSubs","touchendSubs","documentMousemoveSubs","documentMouseupSubs","mousedownSubs","mousemoveSubs","mouseupSubs","draggable","resizable","max_cols","max_rows","visible_cols","visible_rows","col_width","row_height","min_width","min_height","fix_to_grid","auto_style","auto_resize","maintain_ratio","prefer_new","zoom_on_drag","limit_to_screen","center_to_screen","resize_directions","element_based_row_height","fix_item_position_direction","fix_collision_position_direction","allow_overlap","Directive","inputs","host","(window:resize)","KeyValueDiffers","ComponentFactoryResolver","Output","NgGridItem","_zIndex","setStyle","_userConfig","configObject","_added","_currentPosition","event","onResizeAny","onChangeStart","onChangeAny","onChange","onChangeStop","onConfigChangeEvent","onDragAny","addClass","isDraggable","_dragHandle","findHandle","target","handleSelector","startElement","targetElem","elementMatches","parentElement","err","isResizable","_resizeHandle","resizeDirections_1","resizeDirections_1_1","direction","_borderSize","_b","_resizeDirections","_c","canResizeInDirection","cursor","getElement","getDragHandle","getResizeHandle","_elemWidth","_elemHeight","_elemLeft","_elemTop","_payload","payload","dragHandle","resizeHandle","borderSize","fixed","isNaN","isFinite","_minCols","_minRows","update","gridPosition","style","getComputedStyle","getPropertyValue","removeClass","matches","oMatchesSelector","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","ownerDocument","querySelectorAll","newWidth","newHeight","originalEvent","oe","changed","changeCheck","ngGridItemChange","Renderer2","ViewContainerRef","NgGridModule","NgModule","declarations","entryComponents","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { NgGridItem } from \"../directives/NgGridItem\";\n\nexport function generateUuid(): string {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\tlet r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n\t\treturn v.toString(16);\n\t});\n}\n\nexport function sortItemsByPositionHorizontal(a: NgGridItem, b: NgGridItem): number {\n\tif (a.col === b.col) { return a.row - b.row; }\n\treturn a.col - b.col;\n}\n\nexport function sortItemsByPositionVertical(a: NgGridItem, b: NgGridItem): number {\n\tif (a.row === b.row) { return a.col - b.col; }\n\treturn a.row - b.row;\n}\n","import { NgGrid } from '../directives/NgGrid';\nimport { NgGridItemPosition, NgGridItemSize } from '../interfaces/INgGrid';\nimport { Component, Directive, ElementRef, Renderer, EventEmitter, Host, ViewEncapsulation, Type, ComponentRef, KeyValueDiffer, KeyValueDiffers, OnInit, OnDestroy, DoCheck, ViewContainerRef, Output } from '@angular/core';\n\n@Component({\n    selector: 'ng-grid-placeholder',\n    template: ''\n})\nexport class NgGridPlaceholder implements OnInit {\n    private _size: NgGridItemSize;\n    private _position: NgGridItemPosition;\n    private _ngGrid: NgGrid;\n    private _cascadeMode: string;\n\n    constructor(private _ngEl: ElementRef, private _renderer: Renderer) { }\n\n    public registerGrid(ngGrid: NgGrid) {\n        this._ngGrid = ngGrid;\n    }\n\n    public ngOnInit(): void {\n        this._renderer.setElementClass(this._ngEl.nativeElement, 'grid-placeholder', true);\n        if (this._ngGrid.autoStyle) this._renderer.setElementStyle(this._ngEl.nativeElement, 'position', 'absolute');\n    }\n\n    public setSize(newSize: NgGridItemSize): void {\n        this._size = newSize;\n        this._recalculateDimensions();\n    }\n\n    public setGridPosition(newPosition: NgGridItemPosition): void {\n        this._position = newPosition;\n        this._recalculatePosition();\n    }\n\n    public setCascadeMode(cascade: string): void {\n        this._cascadeMode = cascade;\n        switch (cascade) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'right':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'down':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'left', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'bottom', '0px');\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'top', null);\n                break;\n        }\n    }\n\n    // Private methods\n    private _setDimensions(w: number, h: number): void {\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'width', w + 'px');\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'height', h + 'px');\n    }\n\n    private _setPosition(x: number, y: number): void {\n        switch (this._cascadeMode) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + x + 'px, ' + y + 'px)');\n                break;\n            case 'right':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + -x + 'px, ' + y + 'px)');\n                break;\n            case 'down':\n                this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'translate(' + x + 'px, ' + -y + 'px)');\n                break;\n        }\n    }\n\n    private _recalculatePosition(): void {\n        const x: number = (this._ngGrid.colWidth + this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._position.col - 1) + this._ngGrid.marginLeft + this._ngGrid.screenMargin;\n        const y: number = (this._ngGrid.rowHeight + this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._position.row - 1) + this._ngGrid.marginTop;\n        this._setPosition(x, y);\n    }\n\n    private _recalculateDimensions(): void {\n        const w: number = (this._ngGrid.colWidth * this._size.x) + ((this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._size.x - 1));\n        const h: number = (this._ngGrid.rowHeight * this._size.y) + ((this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._size.y - 1));\n        this._setDimensions(w, h);\n    }\n}\n","import { Component, Directive, ElementRef, Renderer, EventEmitter, ComponentFactoryResolver, Host, ViewEncapsulation, Type, ComponentRef, KeyValueDiffer, KeyValueDiffers, OnInit, OnDestroy, DoCheck, ViewContainerRef, Output } from '@angular/core';\nimport { NgGridConfig, NgGridItemEvent, NgGridItemPosition, NgGridItemSize, NgGridRawPosition, NgGridItemDimensions, NgConfigFixDirection } from '../interfaces/INgGrid';\nimport { NgGridItem } from './NgGridItem';\nimport * as NgGridHelper from '../helpers/NgGridHelpers';\nimport { NgGridPlaceholder } from '../components/NgGridPlaceholder';\nimport { Subscription, Observable, fromEvent } from 'rxjs';\n\n@Directive({\n    selector: '[ngGrid]',\n    inputs: ['config: ngGrid'],\n    host: {\n        '(window:resize)': 'resizeEventHandler($event)',\n    }\n})\nexport class NgGrid implements OnInit, DoCheck, OnDestroy {\n    public static CONST_DEFAULT_RESIZE_DIRECTIONS: string[] = [\n        'bottomright',\n        'bottomleft',\n        'topright',\n        'topleft',\n        'right',\n        'left',\n        'bottom',\n        'top',\n    ];\n\n    // Event Emitters\n    @Output() public onDragStart: EventEmitter<NgGridItem> = new EventEmitter<NgGridItem>();\n    @Output() public onDrag: EventEmitter<NgGridItem> = new EventEmitter<NgGridItem>();\n    @Output() public onDragStop: EventEmitter<NgGridItem> = new EventEmitter<NgGridItem>();\n    @Output() public onResizeStart: EventEmitter<NgGridItem> = new EventEmitter<NgGridItem>();\n    @Output() public onResize: EventEmitter<NgGridItem> = new EventEmitter<NgGridItem>();\n    @Output() public onResizeStop: EventEmitter<NgGridItem> = new EventEmitter<NgGridItem>();\n    @Output() public onItemChange: EventEmitter<Array<NgGridItemEvent>> = new EventEmitter<Array<NgGridItemEvent>>();\n\n    // Public variables\n    public colWidth: number = 250;\n    public rowHeight: number = 250;\n    public minCols: number = 1;\n    public minRows: number = 1;\n    public marginTop: number = 10;\n    public marginRight: number = 10;\n    public marginBottom: number = 10;\n    public marginLeft: number = 10;\n    public screenMargin: number = 0;\n    public isDragging: boolean = false;\n    public isResizing: boolean = false;\n    public autoStyle: boolean = true;\n    public resizeEnable: boolean = true;\n    public dragEnable: boolean = true;\n    public cascade: string = 'up';\n    public minWidth: number = 100;\n    public minHeight: number = 100;\n    public resizeDirections: string[] = NgGrid.CONST_DEFAULT_RESIZE_DIRECTIONS;\n\n    // Private variables\n    private _items: Map<string, NgGridItem> = new Map<string, NgGridItem>();\n    private _draggingItem: NgGridItem = null;\n    private _resizingItem: NgGridItem = null;\n    private _resizeDirection: string = null;\n    private _itemsInGrid: Set<string> = new Set<string>();\n    private _containerWidth: number;\n    private _containerHeight: number;\n    private _maxCols: number = 0;\n    private _maxRows: number = 0;\n    private _visibleCols: number = 0;\n    private _visibleRows: number = 0;\n    private _setWidth: number = 250;\n    private _setHeight: number = 250;\n    private _posOffset: NgGridRawPosition = null;\n    private _adding: boolean = false;\n    private _placeholderRef: ComponentRef<NgGridPlaceholder> = null;\n    private _fixToGrid: boolean = false;\n    private _autoResize: boolean = false;\n    private _differ: KeyValueDiffer<string, any>;\n    private _destroyed: boolean = false;\n    private _maintainRatio: boolean = false;\n    private _aspectRatio: number;\n    private _preferNew: boolean = false;\n    private _zoomOnDrag: boolean = false;\n    private _limitToScreen: boolean = false;\n    private _centerToScreen: boolean = false;\n    private _curMaxRow: number = 0;\n    private _curMaxCol: number = 0;\n    private _dragReady: boolean = false;\n    private _resizeReady: boolean = false;\n    private _elementBasedDynamicRowHeight: boolean = false;\n    private _itemFixDirection: NgConfigFixDirection = 'cascade';\n    private _collisionFixDirection: NgConfigFixDirection = 'cascade';\n    private _allowOverlap: boolean = false;\n    private _cascadePromise: Promise<void>;\n    private _lastZValue: number = 1;\n\n    // Events\n    private _documentMousemove$: Observable<MouseEvent>;\n    private _documentMouseup$: Observable<MouseEvent>;\n    private _mousedown$: Observable<MouseEvent>;\n    private _mousemove$: Observable<MouseEvent>;\n    private _mouseup$: Observable<MouseEvent>;\n    private _touchstart$: Observable<TouchEvent>;\n    private _touchmove$: Observable<TouchEvent>;\n    private _touchend$: Observable<TouchEvent>;\n    private _subscriptions: Subscription[] = [];\n\n    private _enabledListener: boolean = false;\n\n    // Default config\n    private static CONST_DEFAULT_CONFIG: NgGridConfig = {\n        margins: [10],\n        draggable: true,\n        resizable: true,\n        max_cols: 0,\n        max_rows: 0,\n        visible_cols: 0,\n        visible_rows: 0,\n        col_width: 250,\n        row_height: 250,\n        cascade: 'up',\n        min_width: 100,\n        min_height: 100,\n        fix_to_grid: false,\n        auto_style: true,\n        auto_resize: false,\n        maintain_ratio: false,\n        prefer_new: false,\n        zoom_on_drag: false,\n        limit_to_screen: false,\n        center_to_screen: false,\n        resize_directions: NgGrid.CONST_DEFAULT_RESIZE_DIRECTIONS,\n        element_based_row_height: false,\n        fix_item_position_direction: 'cascade',\n        fix_collision_position_direction: 'cascade',\n        allow_overlap: false,\n    };\n    private _config = NgGrid.CONST_DEFAULT_CONFIG;\n\n    // [ng-grid] attribute handler\n    set config(v: NgGridConfig) {\n        if (v == null || typeof v !== 'object') {\n            return;\n        }\n\n        this.setConfig(v);\n\n        if (this._differ == null && v != null) {\n            this._differ = this._differs.find(this._config).create();\n        }\n\n        this._differ.diff(this._config);\n    }\n\n    // Constructor\n    constructor(\n        private _differs: KeyValueDiffers,\n        private _ngEl: ElementRef,\n        private _renderer: Renderer,\n        private componentFactoryResolver: ComponentFactoryResolver,\n    ) {\n        this._defineListeners();\n    }\n\n    // Public methods\n    public ngOnInit(): void {\n        this._renderer.setElementClass(this._ngEl.nativeElement, 'grid', true);\n        if (this.autoStyle) this._renderer.setElementStyle(this._ngEl.nativeElement, 'position', 'relative');\n        this.setConfig(this._config);\n    }\n\n    public ngOnDestroy(): void {\n        this._destroyed = true;\n        this._disableListeners();\n    }\n\n    public generateItemUid(): string {\n        const uid: string = NgGridHelper.generateUuid();\n\n        if (this._items.has(uid)) {\n            return this.generateItemUid();\n        }\n\n        return uid;\n    }\n\n    public setConfig(config: NgGridConfig): void {\n        this._config = config;\n\n        var maxColRowChanged = false;\n        for (var x in config) {\n            var val = config[x];\n            var intVal = !val ? 0 : parseInt(val);\n\n            switch (x) {\n                case 'margins':\n                    this.setMargins(val);\n                    break;\n                case 'col_width':\n                    this.colWidth = Math.max(intVal, 1);\n                    break;\n                case 'row_height':\n                    this.rowHeight = Math.max(intVal, 1);\n                    break;\n                case 'auto_style':\n                    this.autoStyle = val ? true : false;\n                    break;\n                case 'auto_resize':\n                    this._autoResize = val ? true : false;\n                    break;\n                case 'draggable':\n                    this.dragEnable = val ? true : false;\n                    break;\n                case 'resizable':\n                    this.resizeEnable = val ? true : false;\n                    break;\n                case 'max_rows':\n                    maxColRowChanged = maxColRowChanged || this._maxRows != intVal;\n                    this._maxRows = intVal < 0 ? 0 : intVal;\n                    break;\n                case 'max_cols':\n                    maxColRowChanged = maxColRowChanged || this._maxCols != intVal;\n                    this._maxCols = intVal < 0 ? 0 : intVal;\n                    break;\n                case 'visible_rows':\n                    this._visibleRows = Math.max(intVal, 0);\n                    break;\n                case 'visible_cols':\n                    this._visibleCols = Math.max(intVal, 0);\n                    break;\n                case 'min_rows':\n                    this.minRows = Math.max(intVal, 1);\n                    break;\n                case 'min_cols':\n                    this.minCols = Math.max(intVal, 1);\n                    break;\n                case 'min_height':\n                    this.minHeight = Math.max(intVal, 1);\n                    break;\n                case 'min_width':\n                    this.minWidth = Math.max(intVal, 1);\n                    break;\n                case 'zoom_on_drag':\n                    this._zoomOnDrag = val ? true : false;\n                    break;\n                case 'cascade':\n                    if (this.cascade != val) {\n                        this.cascade = val;\n                        this._cascadeGrid();\n                    }\n                    break;\n                case 'fix_to_grid':\n                    this._fixToGrid = val ? true : false;\n                    break;\n                case 'maintain_ratio':\n                    this._maintainRatio = val ? true : false;\n                    break;\n                case 'prefer_new':\n                    this._preferNew = val ? true : false;\n                    break;\n                case 'limit_to_screen':\n                    this._limitToScreen = !this._autoResize && !!val;\n                    break;\n                case 'center_to_screen':\n                    this._centerToScreen = val ? true : false;\n                    break;\n                case 'resize_directions':\n                    this.resizeDirections = val || ['bottomright', 'bottomleft', 'topright', 'topleft', 'right', 'left', 'bottom', 'top'];\n                    break;\n                case 'element_based_row_height':\n                    this._elementBasedDynamicRowHeight = !!val;\n                    break;\n                case 'fix_item_position_direction':\n                    this._itemFixDirection = val;\n                    break;\n                case 'fix_collision_position_direction':\n                    this._collisionFixDirection = val;\n                    break;\n                case 'allow_overlap':\n                    this._allowOverlap = !!val;\n                    break;\n            }\n        }\n\n        if (this._allowOverlap && this.cascade !== 'off' && this.cascade !== '') {\n            console.warn('Unable to overlap items when a cascade direction is set.');\n            this._allowOverlap = false;\n        }\n\n        if (this.dragEnable || this.resizeEnable) {\n            this._enableListeners();\n        } else {\n            this._disableListeners();\n        }\n\n        if (this._itemFixDirection === 'cascade') {\n            this._itemFixDirection = this._getFixDirectionFromCascade();\n        }\n\n        if (this._collisionFixDirection === 'cascade') {\n            this._collisionFixDirection = this._getFixDirectionFromCascade();\n        }\n\n        if (this._limitToScreen) {\n            const newMaxCols = this._getContainerColumns();\n\n            if (this._maxCols != newMaxCols) {\n                this._maxCols = newMaxCols;\n                maxColRowChanged = true;\n            }\n        }\n\n        if (this._limitToScreen && this._centerToScreen) {\n            this.screenMargin = this._getScreenMargin();\n        } else {\n            this.screenMargin = 0;\n        }\n\n        if (this._maintainRatio) {\n            if (this.colWidth && this.rowHeight) {\n                this._aspectRatio = this.colWidth / this.rowHeight;\n            } else {\n                this._maintainRatio = false;\n            }\n        }\n\n        if (maxColRowChanged) {\n            if (this._maxCols > 0 && this._maxRows > 0) {    //    Can't have both, prioritise on cascade\n                switch (this.cascade) {\n                    case 'left':\n                    case 'right':\n                        this._maxCols = 0;\n                        break;\n                    case 'up':\n                    case 'down':\n                    default:\n                        this._maxRows = 0;\n                        break;\n                }\n            }\n\n            this._updatePositionsAfterMaxChange();\n        }\n\n        this._calculateColWidth();\n        this._calculateRowHeight();\n\n        var maxWidth = this._maxCols * this.colWidth;\n        var maxHeight = this._maxRows * this.rowHeight;\n\n        if (maxWidth > 0 && this.minWidth > maxWidth) this.minWidth = 0.75 * this.colWidth;\n        if (maxHeight > 0 && this.minHeight > maxHeight) this.minHeight = 0.75 * this.rowHeight;\n\n        if (this.minWidth > this.colWidth) this.minCols = Math.max(this.minCols, Math.ceil(this.minWidth / this.colWidth));\n        if (this.minHeight > this.rowHeight) this.minRows = Math.max(this.minRows, Math.ceil(this.minHeight / this.rowHeight));\n\n        if (this._maxCols > 0 && this.minCols > this._maxCols) this.minCols = 1;\n        if (this._maxRows > 0 && this.minRows > this._maxRows) this.minRows = 1;\n\n        this._updateRatio();\n\n        this._items.forEach((item: NgGridItem) => {\n            this._removeFromGrid(item);\n            item.setCascadeMode(this.cascade);\n        });\n\n        this._items.forEach((item: NgGridItem) => {\n            item.recalculateSelf();\n            this._addToGrid(item);\n        });\n\n        this._cascadeGrid();\n        this._updateSize();\n    }\n\n    public getItemPosition(itemId: string): NgGridItemPosition {\n        return this._items.has(itemId) ? this._items.get(itemId).getGridPosition() : null;\n    }\n\n    public getItemSize(itemId: string): NgGridItemSize {\n        return this._items.has(itemId) ? this._items.get(itemId).getSize() : null;\n    }\n\n    public ngDoCheck(): boolean {\n        if (this._differ != null) {\n            var changes = this._differ.diff(this._config);\n\n            if (changes != null) {\n                this._applyChanges(changes);\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public setMargins(margins: Array<string>): void {\n        this.marginTop = Math.max(parseInt(margins[0]), 0);\n        this.marginRight = margins.length >= 2 ? Math.max(parseInt(margins[1]), 0) : this.marginTop;\n        this.marginBottom = margins.length >= 3 ? Math.max(parseInt(margins[2]), 0) : this.marginTop;\n        this.marginLeft = margins.length >= 4 ? Math.max(parseInt(margins[3]), 0) : this.marginRight;\n    }\n\n    public enableDrag(): void {\n        this.dragEnable = true;\n    }\n\n    public disableDrag(): void {\n        this.dragEnable = false;\n    }\n\n    public enableResize(): void {\n        this.resizeEnable = true;\n    }\n\n    public disableResize(): void {\n        this.resizeEnable = false;\n    }\n\n    public addItem(ngItem: NgGridItem): void {\n        ngItem.setCascadeMode(this.cascade);\n\n        if (!this._preferNew) {\n            var newPos = this._fixGridPosition(ngItem.getGridPosition(), ngItem.getSize());\n            ngItem.setGridPosition(newPos);\n        }\n\n        if (ngItem.uid === null || this._items.has(ngItem.uid)) {\n            ngItem.uid = this.generateItemUid();\n        }\n\n        this._items.set(ngItem.uid, ngItem);\n        this._addToGrid(ngItem);\n\n        this._updateSize();\n\n        this.triggerCascade().then(() => {\n            ngItem.recalculateSelf();\n            ngItem.onCascadeEvent();\n\n            this._emitOnItemChange();\n        });\n\n    }\n\n    public removeItem(ngItem: NgGridItem): void {\n        this._removeFromGrid(ngItem);\n\n        this._items.delete(ngItem.uid);\n\n        if (this._destroyed) return;\n\n        this.triggerCascade().then(() => {\n            this._updateSize();\n            this._items.forEach((item: NgGridItem) => item.recalculateSelf());\n            this._emitOnItemChange();\n        });\n    }\n\n    public updateItem(ngItem: NgGridItem): void {\n        this._removeFromGrid(ngItem);\n        this._addToGrid(ngItem);\n\n        this.triggerCascade().then(() => {\n            this._updateSize();\n            ngItem.onCascadeEvent();\n        });\n    }\n\n    public triggerCascade(): Promise<void> {\n        if (!this._cascadePromise) {\n            this._cascadePromise = new Promise<void>((resolve: () => void) => {\n                setTimeout(() => {\n                    this._cascadePromise = null;\n                    this._cascadeGrid(null, null);\n                    resolve();\n                }, 0);\n            });\n        }\n\n        return this._cascadePromise;\n    }\n\n    public triggerResize(): void {\n        this.resizeEventHandler(null);\n    }\n\n    public resizeEventHandler(e: any): void {\n        this._calculateColWidth();\n        this._calculateRowHeight();\n\n        this._updateRatio();\n\n        if (this._limitToScreen) {\n            const newMaxColumns = this._getContainerColumns();\n            if (this._maxCols !== newMaxColumns) {\n                this._maxCols = newMaxColumns;\n                this._updatePositionsAfterMaxChange();\n                this._cascadeGrid();\n            }\n\n            if (this._centerToScreen) {\n                this.screenMargin = this._getScreenMargin();\n\n                this._items.forEach((item: NgGridItem) => {\n                    item.recalculateSelf();\n                });\n            }\n        } else if (this._autoResize) {\n            this._items.forEach((item: NgGridItem) => {\n                item.recalculateSelf();\n            });\n        }\n\n        this._updateSize();\n    }\n\n    public mouseDownEventHandler(e: MouseEvent | TouchEvent): void {\n        var mousePos = this._getMousePosition(e);\n        var item = this._getItemFromPosition(mousePos);\n\n        if (item == null) return;\n\n        const resizeDirection: string = item.canResize(e);\n\n        if (this.resizeEnable && resizeDirection) {\n            this._resizeReady = true;\n            this._resizingItem = item;\n            this._resizeDirection = resizeDirection;\n\n            e.preventDefault();\n        } else if (this.dragEnable && item.canDrag(e)) {\n            this._dragReady = true;\n            this._draggingItem = item;\n\n            const itemPos = item.getPosition();\n            this._posOffset = { 'left': (mousePos.left - itemPos.left), 'top': (mousePos.top - itemPos.top) }\n\n            e.preventDefault();\n        }\n    }\n\n    public mouseUpEventHandler(e: MouseEvent | TouchEvent): void {\n        if (this.isDragging) {\n            this._dragStop(e);\n        } else if (this.isResizing) {\n            this._resizeStop(e);\n        } else if (this._dragReady || this._resizeReady) {\n            this._cleanDrag();\n            this._cleanResize();\n        }\n    }\n\n    public mouseMoveEventHandler(e: MouseEvent | TouchEvent): void {\n        if (this._resizeReady) {\n            this._resizeStart(e);\n            e.preventDefault();\n            return;\n        } else if (this._dragReady) {\n            this._dragStart(e);\n            e.preventDefault();\n            return;\n        }\n\n        if (this.isDragging) {\n            this._drag(e);\n        } else if (this.isResizing) {\n            this._resize(e);\n        } else {\n            var mousePos = this._getMousePosition(e);\n            var item = this._getItemFromPosition(mousePos);\n\n            if (item) {\n                item.onMouseMove(e);\n            }\n        }\n    }\n\n    //    Private methods\n    private _getFixDirectionFromCascade(): NgConfigFixDirection {\n        switch (this.cascade) {\n            case 'up':\n            case 'down':\n            default:\n                return 'vertical';\n            case 'left':\n            case 'right':\n                return 'horizontal';\n        }\n    }\n    private _updatePositionsAfterMaxChange(): void {\n        this._items.forEach((item: NgGridItem) => {\n            var pos = item.getGridPosition();\n            var dims = item.getSize();\n\n            if (!this._hasGridCollision(pos, dims) && this._isWithinBounds(pos, dims) && dims.x <= this._maxCols && dims.y <= this._maxRows) {\n                return;\n            }\n\n            this._removeFromGrid(item);\n\n            if (this._maxCols > 0 && dims.x > this._maxCols) {\n                dims.x = this._maxCols;\n                item.setSize(dims);\n            } else if (this._maxRows > 0 && dims.y > this._maxRows) {\n                dims.y = this._maxRows;\n                item.setSize(dims);\n            }\n\n            if (this._hasGridCollision(pos, dims) || !this._isWithinBounds(pos, dims, true)) {\n                var newPosition = this._fixGridPosition(pos, dims);\n                item.setGridPosition(newPosition);\n            }\n\n            this._addToGrid(item);\n        });\n    }\n\n    private _calculateColWidth(): void {\n        if (this._autoResize) {\n            if (this._maxCols > 0 || this._visibleCols > 0) {\n                var maxCols = this._maxCols > 0 ? this._maxCols : this._visibleCols;\n                var maxWidth: number = this._ngEl.nativeElement.getBoundingClientRect().width;\n\n                var colWidth: number = Math.floor(maxWidth / maxCols);\n                colWidth -= (this.marginLeft + this.marginRight);\n                if (colWidth > 0) this.colWidth = colWidth;\n\n            }\n        }\n\n        if (this.colWidth < this.minWidth || this.minCols > this._config.min_cols) {\n            this.minCols = Math.max(this._config.min_cols, Math.ceil(this.minWidth / this.colWidth));\n        }\n    }\n\n    private _calculateRowHeight(): void {\n        if (this._autoResize) {\n            if (this._maxRows > 0 || this._visibleRows > 0) {\n                var maxRows = this._maxRows > 0 ? this._maxRows : this._visibleRows;\n                let maxHeight: number;\n\n                if (this._elementBasedDynamicRowHeight) {\n                    maxHeight = this._ngEl.nativeElement.getBoundingClientRect().height;\n                } else {\n                    maxHeight = window.innerHeight - this.marginTop - this.marginBottom;\n                }\n\n                var rowHeight: number = Math.max(Math.floor(maxHeight / maxRows), this.minHeight);\n                rowHeight -= (this.marginTop + this.marginBottom);\n                if (rowHeight > 0) this.rowHeight = rowHeight;\n\n            }\n        }\n\n        if (this.rowHeight < this.minHeight || this.minRows > this._config.min_rows) {\n            this.minRows = Math.max(this._config.min_rows, Math.ceil(this.minHeight / this.rowHeight));\n        }\n    }\n\n    private _updateRatio(): void {\n        if (!this._autoResize || !this._maintainRatio) return;\n\n        if (this._maxCols > 0 && this._visibleRows <= 0) {\n            this.rowHeight = this.colWidth / this._aspectRatio;\n        } else if (this._maxRows > 0 && this._visibleCols <= 0) {\n            this.colWidth = this._aspectRatio * this.rowHeight;\n        } else if (this._maxCols == 0 && this._maxRows == 0) {\n            if (this._visibleCols > 0) {\n                this.rowHeight = this.colWidth / this._aspectRatio;\n            } else if (this._visibleRows > 0) {\n                this.colWidth = this._aspectRatio * this.rowHeight;\n            }\n        }\n    }\n\n    private _applyChanges(changes: any): void {\n        changes.forEachAddedItem((record: any) => { this._config[record.key] = record.currentValue; });\n        changes.forEachChangedItem((record: any) => { this._config[record.key] = record.currentValue; });\n        changes.forEachRemovedItem((record: any) => { delete this._config[record.key]; });\n\n        this.setConfig(this._config);\n    }\n\n    private _resizeStart(e: any): void {\n        if (!this.resizeEnable || !this._resizingItem) return;\n\n        //    Setup\n        this._resizingItem.startMoving();\n        this._removeFromGrid(this._resizingItem);\n        this._createPlaceholder(this._resizingItem);\n\n        if (this._allowOverlap) {\n            this._resizingItem.zIndex = this._lastZValue++;\n        }\n\n        //    Status Flags\n        this.isResizing = true;\n        this._resizeReady = false;\n\n        //    Events\n        this.onResizeStart.emit(this._resizingItem);\n        this._resizingItem.onResizeStartEvent();\n    }\n\n    private _dragStart(e: any): void {\n        if (!this.dragEnable || !this._draggingItem) return;\n\n        //    Start dragging\n        this._draggingItem.startMoving();\n        this._removeFromGrid(this._draggingItem);\n        this._createPlaceholder(this._draggingItem);\n\n        if (this._allowOverlap) {\n            this._draggingItem.zIndex = this._lastZValue++;\n        }\n\n        //    Status Flags\n        this.isDragging = true;\n        this._dragReady = false;\n\n        //    Events\n        this.onDragStart.emit(this._draggingItem);\n        this._draggingItem.onDragStartEvent();\n\n        //    Zoom\n        if (this._zoomOnDrag) {\n            this._zoomOut();\n        }\n    }\n\n    private _zoomOut(): void {\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', 'scale(0.5, 0.5)');\n    }\n\n    private _resetZoom(): void {\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'transform', '');\n    }\n\n    private _drag(e: any): void {\n        if (!this.isDragging) return;\n\n        if (window.getSelection) {\n            if (window.getSelection().empty) {\n                window.getSelection().empty();\n            } else if (window.getSelection().removeAllRanges) {\n                window.getSelection().removeAllRanges();\n            }\n        } else if ((<any>document).selection) {\n            (<any>document).selection.empty();\n        }\n\n        var mousePos = this._getMousePosition(e);\n        var newL = (mousePos.left - this._posOffset.left);\n        var newT = (mousePos.top - this._posOffset.top);\n\n        var itemPos = this._draggingItem.getGridPosition();\n        var gridPos = this._calculateGridPosition(newL, newT);\n        var dims = this._draggingItem.getSize();\n\n        gridPos = this._fixPosToBoundsX(gridPos, dims);\n\n        if (!this._isWithinBoundsY(gridPos, dims)) {\n            gridPos = this._fixPosToBoundsY(gridPos, dims);\n        }\n\n        if (gridPos.col != itemPos.col || gridPos.row != itemPos.row) {\n            this._draggingItem.setGridPosition(gridPos, this._fixToGrid);\n            this._placeholderRef.instance.setGridPosition(gridPos);\n\n            if (['up', 'down', 'left', 'right'].indexOf(this.cascade) >= 0) {\n                this._fixGridCollisions(gridPos, dims);\n                this._cascadeGrid(gridPos, dims);\n            }\n        }\n\n        if (!this._fixToGrid) {\n            this._draggingItem.setPosition(newL, newT);\n        }\n\n        this.onDrag.emit(this._draggingItem);\n        this._draggingItem.onDragEvent();\n    }\n\n    private _resize(e: any): void {\n        if (!this.isResizing) { return; }\n\n        if (window.getSelection) {\n            if (window.getSelection().empty) {\n                window.getSelection().empty();\n            } else if (window.getSelection().removeAllRanges) {\n                window.getSelection().removeAllRanges();\n            }\n        } else if ((<any>document).selection) {\n            (<any>document).selection.empty();\n        }\n\n        const mousePos = this._getMousePosition(e);\n        const itemPos = this._resizingItem.getPosition();\n        const itemDims = this._resizingItem.getDimensions();\n        const endCorner = {\n            left: itemPos.left + itemDims.width,\n            top: itemPos.top + itemDims.height,\n        }\n\n        const resizeTop = this._resizeDirection.includes('top');\n        const resizeBottom = this._resizeDirection.includes('bottom');\n        const resizeLeft = this._resizeDirection.includes('left')\n        const resizeRight = this._resizeDirection.includes('right');\n\n        // Calculate new width and height based upon resize direction\n        let newW = resizeRight\n            ? (mousePos.left - itemPos.left + 1)\n            : resizeLeft\n                ? (endCorner.left - mousePos.left + 1)\n                : itemDims.width;\n        let newH = resizeBottom\n            ? (mousePos.top - itemPos.top + 1)\n            : resizeTop\n                ? (endCorner.top - mousePos.top + 1)\n                : itemDims.height;\n\n        if (newW < this.minWidth)\n            newW = this.minWidth;\n        if (newH < this.minHeight)\n            newH = this.minHeight;\n        if (newW < this._resizingItem.minWidth)\n            newW = this._resizingItem.minWidth;\n        if (newH < this._resizingItem.minHeight)\n            newH = this._resizingItem.minHeight;\n\n        let newX = itemPos.left;\n        let newY = itemPos.top;\n\n        if (resizeLeft)\n            newX = endCorner.left - newW;\n        if (resizeTop)\n            newY = endCorner.top - newH;\n\n        let calcSize = this._calculateGridSize(newW, newH);\n        const itemSize = this._resizingItem.getSize();\n        const iGridPos = this._resizingItem.getGridPosition();\n        const bottomRightCorner = {\n            col: iGridPos.col + itemSize.x,\n            row: iGridPos.row + itemSize.y,\n        };\n        const targetPos: NgGridItemPosition = Object.assign({}, iGridPos);\n\n        if (this._resizeDirection.includes('top'))\n            targetPos.row = bottomRightCorner.row - calcSize.y;\n        if (this._resizeDirection.includes('left'))\n            targetPos.col = bottomRightCorner.col - calcSize.x;\n\n        if (!this._isWithinBoundsX(targetPos, calcSize))\n            calcSize = this._fixSizeToBoundsX(targetPos, calcSize);\n\n        if (!this._isWithinBoundsY(targetPos, calcSize))\n            calcSize = this._fixSizeToBoundsY(targetPos, calcSize);\n\n        calcSize = this._resizingItem.fixResize(calcSize);\n\n        if (calcSize.x != itemSize.x || calcSize.y != itemSize.y) {\n            this._resizingItem.setGridPosition(targetPos, this._fixToGrid);\n            this._placeholderRef.instance.setGridPosition(targetPos);\n            this._resizingItem.setSize(calcSize, this._fixToGrid);\n            this._placeholderRef.instance.setSize(calcSize);\n\n            if (['up', 'down', 'left', 'right'].indexOf(this.cascade) >= 0) {\n                this._fixGridCollisions(targetPos, calcSize);\n                this._cascadeGrid(targetPos, calcSize);\n            }\n        }\n\n        if (!this._fixToGrid) {\n            this._resizingItem.setDimensions(newW, newH);\n            this._resizingItem.setPosition(newX, newY);\n        }\n\n        this.onResize.emit(this._resizingItem);\n        this._resizingItem.onResizeEvent();\n    }\n\n    private _dragStop(e: any): void {\n        if (!this.isDragging) return;\n\n        this.isDragging = false;\n\n        var itemPos = this._draggingItem.getGridPosition();\n\n        this._draggingItem.setGridPosition(itemPos);\n        this._addToGrid(this._draggingItem);\n\n        this._cascadeGrid();\n        this._updateSize();\n\n        this._draggingItem.stopMoving();\n        this._draggingItem.onDragStopEvent();\n        this.onDragStop.emit(this._draggingItem);\n\n        this._cleanDrag();\n        this._placeholderRef.destroy();\n\n        this._emitOnItemChange();\n\n        if (this._zoomOnDrag) {\n            this._resetZoom();\n        }\n    }\n\n    private _resizeStop(e: any): void {\n        if (!this.isResizing) return;\n\n        this.isResizing = false;\n\n        const itemDims = this._resizingItem.getSize();\n        this._resizingItem.setSize(itemDims);\n\n        const itemPos = this._resizingItem.getGridPosition();\n        this._resizingItem.setGridPosition(itemPos);\n\n        this._addToGrid(this._resizingItem);\n\n        this._cascadeGrid();\n        this._updateSize();\n\n        this._resizingItem.stopMoving();\n        this._resizingItem.onResizeStopEvent();\n        this.onResizeStop.emit(this._resizingItem);\n\n        this._cleanResize();\n        this._placeholderRef.destroy();\n\n        this._emitOnItemChange();\n    }\n\n    private _cleanDrag(): void {\n        this._draggingItem = null;\n        this._posOffset = null;\n        this.isDragging = false;\n        this._dragReady = false;\n    }\n\n    private _cleanResize(): void {\n        this._resizingItem = null;\n        this._resizeDirection = null;\n        this.isResizing = false;\n        this._resizeReady = false;\n    }\n\n    private _calculateGridSize(width: number, height: number): NgGridItemSize {\n        width += this.marginLeft + this.marginRight;\n        height += this.marginTop + this.marginBottom;\n\n        var sizex = Math.max(this.minCols, Math.round(width / (this.colWidth + this.marginLeft + this.marginRight)));\n        var sizey = Math.max(this.minRows, Math.round(height / (this.rowHeight + this.marginTop + this.marginBottom)));\n\n        if (!this._isWithinBoundsX({ col: 1, row: 1 }, { x: sizex, y: sizey })) sizex = this._maxCols;\n        if (!this._isWithinBoundsY({ col: 1, row: 1 }, { x: sizex, y: sizey })) sizey = this._maxRows;\n\n        return { 'x': sizex, 'y': sizey };\n    }\n\n    private _calculateGridPosition(left: number, top: number): NgGridItemPosition {\n        var col = Math.max(1, Math.round(left / (this.colWidth + this.marginLeft + this.marginRight)) + 1);\n        var row = Math.max(1, Math.round(top / (this.rowHeight + this.marginTop + this.marginBottom)) + 1);\n\n        if (!this._isWithinBoundsX({ col: col, row: row }, { x: 1, y: 1 })) col = this._maxCols;\n        if (!this._isWithinBoundsY({ col: col, row: row }, { x: 1, y: 1 })) row = this._maxRows;\n\n        return { 'col': col, 'row': row };\n    }\n\n    private _hasGridCollision(pos: NgGridItemPosition, dims: NgGridItemSize): boolean {\n        var positions = this._getCollisions(pos, dims);\n\n        if (positions == null || positions.length == 0) return false;\n\n        return positions.some((v: NgGridItem) => {\n            return !(v === null);\n        });\n    }\n\n    private _getCollisions(pos: NgGridItemPosition, dims: NgGridItemSize): Array<NgGridItem> {\n        if (this._allowOverlap) return [];\n\n        const returns: Array<NgGridItem> = [];\n\n        if (!pos.col) { pos.col = 1; }\n        if (!pos.row) { pos.row = 1; }\n\n        const leftCol = pos.col;\n        const rightCol = pos.col + dims.x;\n        const topRow = pos.row;\n        const bottomRow = pos.row + dims.y;\n\n        this._itemsInGrid.forEach((itemId: string) => {\n            const item: NgGridItem = this._items.get(itemId);\n\n            if (!item) {\n                this._itemsInGrid.delete(itemId);\n                return;\n            }\n\n            const itemLeftCol = item.col;\n            const itemRightCol = item.col + item.sizex;\n            const itemTopRow = item.row;\n            const itemBottomRow = item.row + item.sizey;\n\n            const withinColumns = leftCol < itemRightCol && itemLeftCol < rightCol;\n            const withinRows = topRow < itemBottomRow && itemTopRow < bottomRow;\n\n            if (withinColumns && withinRows) {\n                returns.push(item);\n            }\n        });\n\n        return returns;\n    }\n\n    private _fixGridCollisions(pos: NgGridItemPosition, dims: NgGridItemSize): void {\n        const collisions: Array<NgGridItem> = this._getCollisions(pos, dims);\n        if (collisions.length === 0) { return; }\n\n        for (let collision of collisions) {\n            this._removeFromGrid(collision);\n\n            const itemDims: NgGridItemSize = collision.getSize();\n            const itemPos: NgGridItemPosition = collision.getGridPosition();\n            let newItemPos: NgGridItemPosition = { col: itemPos.col, row: itemPos.row };\n\n            if (this._collisionFixDirection === 'vertical') {\n                newItemPos.row = pos.row + dims.y;\n\n                if (!this._isWithinBoundsY(newItemPos, itemDims)) {\n                    newItemPos.col = pos.col + dims.x;\n                    newItemPos.row = 1;\n                }\n            } else if (this._collisionFixDirection === 'horizontal') {\n                newItemPos.col = pos.col + dims.x;\n\n                if (!this._isWithinBoundsX(newItemPos, itemDims)) {\n                    newItemPos.col = 1;\n                    newItemPos.row = pos.row + dims.y;\n                }\n            }\n\n            collision.setGridPosition(newItemPos);\n\n            this._fixGridCollisions(newItemPos, itemDims);\n            this._addToGrid(collision);\n            collision.onCascadeEvent();\n        }\n\n        this._fixGridCollisions(pos, dims);\n    }\n\n    private _cascadeGrid(pos?: NgGridItemPosition, dims?: NgGridItemSize): void {\n        if (this._destroyed) return;\n        if (this._allowOverlap) return;\n        if (!pos !== !dims) throw new Error('Cannot cascade with only position and not dimensions');\n\n        if (this.isDragging && this._draggingItem && !pos && !dims) {\n            pos = this._draggingItem.getGridPosition();\n            dims = this._draggingItem.getSize();\n        } else if (this.isResizing && this._resizingItem && !pos && !dims) {\n            pos = this._resizingItem.getGridPosition();\n            dims = this._resizingItem.getSize();\n        }\n\n        let itemsInGrid: NgGridItem[] = Array.from(this._itemsInGrid, (itemId: string) => this._items.get(itemId));\n\n        switch (this.cascade) {\n            case 'up':\n            case 'down':\n                itemsInGrid = itemsInGrid.sort(NgGridHelper.sortItemsByPositionVertical);\n                const lowestRowPerColumn: Map<number, number> = new Map<number, number>();\n\n                for (let item of itemsInGrid) {\n                    if (item.isFixed) continue;\n\n                    const itemDims: NgGridItemSize = item.getSize();\n                    const itemPos: NgGridItemPosition = item.getGridPosition();\n\n                    let lowestRowForItem: number = lowestRowPerColumn.get(itemPos.col) || 1;\n\n                    for (let i: number = 1; i < itemDims.x; i++) {\n                        const lowestRowForColumn = lowestRowPerColumn.get(itemPos.col + i) || 1;\n                        lowestRowForItem = Math.max(lowestRowForColumn, lowestRowForItem);\n                    }\n\n                    const leftCol = itemPos.col;\n                    const rightCol = itemPos.col + itemDims.x;\n\n                    if (pos && dims) {\n                        const withinColumns = rightCol > pos.col && leftCol < (pos.col + dims.x);\n\n                        if (withinColumns) {          // If our element is in one of the item's columns\n                            const roomAboveItem = itemDims.y <= (pos.row - lowestRowForItem);\n\n                            if (!roomAboveItem) {                                                  // Item can't fit above our element\n                                lowestRowForItem = Math.max(lowestRowForItem, pos.row + dims.y);   // Set the lowest row to be below it\n                            }\n                        }\n                    }\n\n                    const newPos: NgGridItemPosition = { col: itemPos.col, row: lowestRowForItem };\n\n                    //    What if it's not within bounds Y?\n                    if (lowestRowForItem != itemPos.row && this._isWithinBoundsY(newPos, itemDims)) { // If the item is not already on this row move it up\n                        this._removeFromGrid(item);\n\n                        item.setGridPosition(newPos);\n\n                        item.onCascadeEvent();\n                        this._addToGrid(item);\n                    }\n\n                    for (let i: number = 0; i < itemDims.x; i++) {\n                        lowestRowPerColumn.set(itemPos.col + i, lowestRowForItem + itemDims.y); // Update the lowest row to be below the item\n                    }\n                }\n                break;\n            case 'left':\n            case 'right':\n                itemsInGrid = itemsInGrid.sort(NgGridHelper.sortItemsByPositionHorizontal);\n                const lowestColumnPerRow: Map<number, number> = new Map<number, number>();\n\n                for (let item of itemsInGrid) {\n                    const itemDims: NgGridItemSize = item.getSize();\n                    const itemPos: NgGridItemPosition = item.getGridPosition();\n\n                    let lowestColumnForItem: number = lowestColumnPerRow.get(itemPos.row) || 1;\n\n                    for (let i: number = 1; i < itemDims.y; i++) {\n                        let lowestOffsetColumn: number = lowestColumnPerRow.get(itemPos.row + i) || 1;\n                        lowestColumnForItem = Math.max(lowestOffsetColumn, lowestColumnForItem);\n                    }\n\n                    const topRow = itemPos.row;\n                    const bottomRow = itemPos.row + itemDims.y;\n\n                    if (pos && dims) {\n                        const withinRows = bottomRow > pos.col && topRow < (pos.col + dims.x);\n\n                        if (withinRows) {          // If our element is in one of the item's rows\n                            const roomNextToItem = itemDims.x <= (pos.col - lowestColumnForItem);\n\n                            if (!roomNextToItem) {                                                      // Item can't fit next to our element\n                                lowestColumnForItem = Math.max(lowestColumnForItem, pos.col + dims.x);  // Set the lowest col to be the other side of it\n                            }\n                        }\n                    }\n\n                    const newPos: NgGridItemPosition = { col: lowestColumnForItem, row: itemPos.row };\n\n                    if (lowestColumnForItem != itemPos.col && this._isWithinBoundsX(newPos, itemDims)) { // If the item is not already on this col move it up\n                        this._removeFromGrid(item);\n\n                        item.setGridPosition(newPos);\n\n                        item.onCascadeEvent();\n                        this._addToGrid(item);\n                    }\n\n                    for (let i: number = 0; i < itemDims.y; i++) {\n                        lowestColumnPerRow.set(itemPos.row + i, lowestColumnForItem + itemDims.x); // Update the lowest col to be below the item\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n\n    private _fixGridPosition(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemPosition {\n        if (!this._hasGridCollision(pos, dims)) return pos;\n\n        const maxRow = this._maxRows === 0 ? this._getMaxRow() : this._maxRows;\n        const maxCol = this._maxCols === 0 ? this._getMaxCol() : this._maxCols;\n        const newPos = {\n            col: pos.col,\n            row: pos.row,\n        };\n\n        if (this._itemFixDirection === 'vertical') {\n            fixLoop:\n            for (; newPos.col <= maxRow;) {\n                const itemsInPath = this._getItemsInVerticalPath(newPos, dims, newPos.row);\n                let nextRow = newPos.row;\n\n                for (let item of itemsInPath) {\n                    if (item.row - nextRow >= dims.y) {\n                        newPos.row = nextRow;\n                        break fixLoop;\n                    }\n\n                    nextRow = item.row + item.sizey;\n                }\n\n                if (maxRow - nextRow >= dims.y) {\n                    newPos.row = nextRow;\n                    break fixLoop;\n                }\n\n                newPos.col = Math.max(newPos.col + 1, Math.min.apply(Math, itemsInPath.map((item) => item.col + dims.x)));\n                newPos.row = 1;\n            }\n        } else if (this._itemFixDirection === 'horizontal') {\n            fixLoop:\n            for (; newPos.row <= maxRow;) {\n                const itemsInPath = this._getItemsInHorizontalPath(newPos, dims, newPos.col);\n                let nextCol = newPos.col;\n\n                for (let item of itemsInPath) {\n                    if (item.col - nextCol >= dims.x) {\n                        newPos.col = nextCol;\n                        break fixLoop;\n                    }\n\n                    nextCol = item.col + item.sizex;\n                }\n\n                if (maxCol - nextCol >= dims.x) {\n                    newPos.col = nextCol;\n                    break fixLoop;\n                }\n\n                newPos.row = Math.max(newPos.row + 1, Math.min.apply(Math, itemsInPath.map((item) => item.row + dims.y)));\n                newPos.col = 1;\n            }\n        }\n\n        return newPos;\n    }\n\n    private _getItemsInHorizontalPath(pos: NgGridItemPosition, dims: NgGridItemSize, startColumn: number = 0): NgGridItem[] {\n        const itemsInPath: NgGridItem[] = [];\n        const topRow: number = pos.row + dims.y - 1;\n\n        this._itemsInGrid.forEach((itemId: string) => {\n            const item = this._items.get(itemId);\n            if (item.col + item.sizex - 1 < startColumn) { return; }    // Item falls after start column\n            if (item.row > topRow) { return; }                          // Item falls above path\n            if (item.row + item.sizey - 1 < pos.row) { return; }        // Item falls below path\n            itemsInPath.push(item);\n        });\n\n        return itemsInPath;\n    }\n\n    private _getItemsInVerticalPath(pos: NgGridItemPosition, dims: NgGridItemSize, startRow: number = 0): NgGridItem[] {\n        const itemsInPath: NgGridItem[] = [];\n        const rightCol: number = pos.col + dims.x - 1;\n\n        this._itemsInGrid.forEach((itemId: string) => {\n            const item = this._items.get(itemId);\n            if (item.row + item.sizey - 1 < startRow) { return; }   // Item falls above start row\n            if (item.col > rightCol) { return; }                    // Item falls after path\n            if (item.col + item.sizex - 1 < pos.col) { return; }    // Item falls before path\n            itemsInPath.push(item);\n        });\n\n        return itemsInPath;\n    }\n\n    private _isWithinBoundsX(pos: NgGridItemPosition, dims: NgGridItemSize, allowExcessiveItems: boolean = false) {\n        return this._maxCols == 0 || (allowExcessiveItems && pos.col == 1) || (pos.col + dims.x - 1) <= this._maxCols;\n    }\n\n    private _fixPosToBoundsX(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemPosition {\n        if (!this._isWithinBoundsX(pos, dims)) {\n            pos.col = Math.max(this._maxCols - (dims.x - 1), 1);\n            pos.row ++;\n        }\n        return pos;\n    }\n\n    private _fixSizeToBoundsX(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemSize {\n        if (!this._isWithinBoundsX(pos, dims)) {\n            dims.x = Math.max(this._maxCols - (pos.col - 1), 1);\n            dims.y++;\n        }\n        return dims;\n    }\n\n    private _isWithinBoundsY(pos: NgGridItemPosition, dims: NgGridItemSize, allowExcessiveItems: boolean = false) {\n        return this._maxRows == 0 || (allowExcessiveItems && pos.row == 1) || (pos.row + dims.y - 1) <= this._maxRows;\n    }\n\n    private _fixPosToBoundsY(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemPosition {\n        if (!this._isWithinBoundsY(pos, dims)) {\n            pos.row = Math.max(this._maxRows - (dims.y - 1), 1);\n            pos.col++;\n        }\n        return pos;\n    }\n\n    private _fixSizeToBoundsY(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemSize {\n        if (!this._isWithinBoundsY(pos, dims)) {\n            dims.y = Math.max(this._maxRows - (pos.row - 1), 1);\n            dims.x++;\n        }\n        return dims;\n    }\n\n    private _isWithinBounds(pos: NgGridItemPosition, dims: NgGridItemSize, allowExcessiveItems: boolean = false) {\n        return this._isWithinBoundsX(pos, dims, allowExcessiveItems) && this._isWithinBoundsY(pos, dims, allowExcessiveItems);\n    }\n\n    private _fixPosToBounds(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemPosition {\n        return this._fixPosToBoundsX(this._fixPosToBoundsY(pos, dims), dims);\n    }\n\n    private _fixSizeToBounds(pos: NgGridItemPosition, dims: NgGridItemSize): NgGridItemSize {\n        return this._fixSizeToBoundsX(pos, this._fixSizeToBoundsY(pos, dims));\n    }\n\n    private _addToGrid(item: NgGridItem): void {\n        let pos: NgGridItemPosition = item.getGridPosition();\n        const dims: NgGridItemSize = item.getSize();\n\n        if (this._hasGridCollision(pos, dims)) {\n            this._fixGridCollisions(pos, dims);\n            pos = item.getGridPosition();\n        }\n\n        if (this._allowOverlap) {\n            item.zIndex = this._lastZValue++;\n        }\n\n        this._itemsInGrid.add(item.uid);\n    }\n\n    private _removeFromGrid(item: NgGridItem): void {\n        this._itemsInGrid.delete(item.uid);\n    }\n\n    private _updateSize(): void {\n        if (this._destroyed) return;\n        let maxCol: number = this._getMaxCol();\n        let maxRow: number = this._getMaxRow();\n\n        if (maxCol != this._curMaxCol || maxRow != this._curMaxRow) {\n            this._curMaxCol = maxCol;\n            this._curMaxRow = maxRow;\n        }\n\n        this._renderer.setElementStyle(this._ngEl.nativeElement, 'width', '100%');//(maxCol * (this.colWidth + this.marginLeft + this.marginRight))+'px');\n        if (!this._elementBasedDynamicRowHeight) {\n            this._renderer.setElementStyle(this._ngEl.nativeElement, 'height', (maxRow * (this.rowHeight + this.marginTop + this.marginBottom)) + 'px');\n        }\n    }\n\n    private _getMaxRow(): number {\n        const itemsRows: number[] = Array.from(this._itemsInGrid, (itemId: string) => {\n            const item = this._items.get(itemId);\n            if (!item) return 0;\n            return item.row + item.sizey - 1;\n        });\n\n        return Math.max.apply(null, itemsRows);\n    }\n\n    private _getMaxCol(): number {\n        const itemsCols: number[] = Array.from(this._itemsInGrid, (itemId: string) => {\n            const item = this._items.get(itemId);\n            if (!item) return 0;\n            return item.col + item.sizex - 1;\n        });\n\n        return Math.max.apply(null, itemsCols);\n    }\n\n    private _getMousePosition(e: any): NgGridRawPosition {\n        if (((<any>window).TouchEvent && e instanceof TouchEvent) || (e.touches || e.changedTouches)) {\n            e = e.touches.length > 0 ? e.touches[0] : e.changedTouches[0];\n        }\n\n        const refPos: any = this._ngEl.nativeElement.getBoundingClientRect();\n\n        let left: number = e.clientX - refPos.left;\n        let top: number = e.clientY - refPos.top;\n\n        if (this.cascade == 'down') top = refPos.top + refPos.height - e.clientY;\n        if (this.cascade == 'right') left = refPos.left + refPos.width - e.clientX;\n\n        if (this.isDragging && this._zoomOnDrag) {\n            left *= 2;\n            top *= 2;\n        }\n\n        return {\n            left: left,\n            top: top\n        };\n    }\n\n    private _getAbsoluteMousePosition(e: any): NgGridRawPosition {\n        if (((<any>window).TouchEvent && e instanceof TouchEvent) || (e.touches || e.changedTouches)) {\n            e = e.touches.length > 0 ? e.touches[0] : e.changedTouches[0];\n        }\n\n        return {\n            left: e.clientX,\n            top: e.clientY\n        };\n    }\n\n    private _getContainerColumns(): number {\n        const maxWidth: number = this._ngEl.nativeElement.getBoundingClientRect().width;\n        const itemWidth: number = this.colWidth + this.marginLeft + this.marginRight;\n        return Math.floor(maxWidth / itemWidth);\n    }\n\n    private _getContainerRows(): number {\n        const maxHeight: number = window.innerHeight - this.marginTop - this.marginBottom;\n        return Math.floor(maxHeight / (this.rowHeight + this.marginTop + this.marginBottom));\n    }\n\n    private _getScreenMargin(): number {\n        const maxWidth: number = this._ngEl.nativeElement.getBoundingClientRect().width;\n        const itemWidth: number = this.colWidth + this.marginLeft + this.marginRight;\n        return Math.floor((maxWidth - (this._maxCols * itemWidth)) / 2);;\n    }\n\n    private _getItemFromPosition(position: NgGridRawPosition): NgGridItem {\n        return Array.from(this._itemsInGrid, (itemId: string) => this._items.get(itemId)).find((item: NgGridItem) => {\n            if (!item) return false;\n\n            const size: NgGridItemDimensions = item.getDimensions();\n            const pos: NgGridRawPosition = item.getPosition();\n\n            return position.left >= pos.left && position.left < (pos.left + size.width) &&\n            position.top >= pos.top && position.top < (pos.top + size.height);\n        });\n    }\n\n    private _createPlaceholder(item: NgGridItem): void {\n        const pos: NgGridItemPosition = item.getGridPosition();\n        const dims: NgGridItemSize = item.getSize();\n\n        const factory = this.componentFactoryResolver.resolveComponentFactory(NgGridPlaceholder);\n        var componentRef: ComponentRef<NgGridPlaceholder> = item.containerRef.createComponent(factory);\n        this._placeholderRef = componentRef;\n        const placeholder: NgGridPlaceholder = componentRef.instance;\n        placeholder.registerGrid(this);\n        placeholder.setCascadeMode(this.cascade);\n        placeholder.setGridPosition({ col: pos.col, row: pos.row });\n        placeholder.setSize({ x: dims.x, y: dims.y });\n    }\n\n    private _emitOnItemChange() {\n        const itemOutput: any[] = Array.from(this._itemsInGrid)\n            .map((itemId: string) => this._items.get(itemId))\n            .filter((item: NgGridItem) => !!item)\n            .map((item: NgGridItem) => item.getEventOutput());\n\n        this.onItemChange.emit(itemOutput);\n    }\n\n    private _defineListeners(): void {\n        const element = this._ngEl.nativeElement;\n\n        this._documentMousemove$ = fromEvent<MouseEvent>(document, 'mousemove');\n        this._documentMouseup$ = fromEvent<MouseEvent>(document, 'mouseup');\n        this._mousedown$ = fromEvent(element, 'mousedown');\n        this._mousemove$ = fromEvent(element, 'mousemove');\n        this._mouseup$ = fromEvent(element, 'mouseup');\n        this._touchstart$ = fromEvent(element, 'touchstart');\n        this._touchmove$ = fromEvent(element, 'touchmove');\n        this._touchend$ = fromEvent(element, 'touchend');\n    }\n\n    private _enableListeners(): void {\n        if (this._enabledListener) {\n            return;\n        }\n\n        this._enableMouseListeners();\n\n        if (this._isTouchDevice()) {\n            this._enableTouchListeners();\n        }\n\n        this._enabledListener = true;\n    }\n\n    private _disableListeners(): void {\n        this._subscriptions.forEach((subs: Subscription) => subs.unsubscribe());\n        this._enabledListener = false;\n    }\n\n    private _isTouchDevice(): boolean {\n        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n    };\n\n    private _enableTouchListeners(): void {\n        const touchstartSubs = this._touchstart$.subscribe((e: TouchEvent) => this.mouseDownEventHandler(e));\n        const touchmoveSubs = this._touchmove$.subscribe((e: TouchEvent) => this.mouseMoveEventHandler(e));\n        const touchendSubs = this._touchend$.subscribe((e: TouchEvent) => this.mouseUpEventHandler(e));\n\n        this._subscriptions.push(\n            touchstartSubs,\n            touchmoveSubs,\n            touchendSubs\n        );\n    }\n\n    private _enableMouseListeners(): void {\n        const documentMousemoveSubs = this._documentMousemove$.subscribe((e: MouseEvent) => this.mouseMoveEventHandler(e));\n        const documentMouseupSubs = this._documentMouseup$.subscribe((e: MouseEvent) => this.mouseUpEventHandler(e));\n        const mousedownSubs = this._mousedown$.subscribe((e: MouseEvent) => this.mouseDownEventHandler(e));\n        const mousemoveSubs = this._mousemove$.subscribe((e: MouseEvent) => this.mouseMoveEventHandler(e));\n        const mouseupSubs = this._mouseup$.subscribe((e: MouseEvent) => this.mouseUpEventHandler(e));\n\n        this._subscriptions.push(\n            documentMousemoveSubs,\n            documentMouseupSubs,\n            mousedownSubs,\n            mousemoveSubs,\n            mouseupSubs\n        );\n    }\n}\n","import { NgGrid } from './NgGrid';\nimport { NgGridItemConfig, NgGridItemEvent, NgGridItemPosition, NgGridItemSize, NgGridRawPosition, NgGridItemDimensions, ResizeHandle } from '../interfaces/INgGrid';\nimport { Directive, ElementRef, Renderer2, EventEmitter, KeyValueDiffer, KeyValueDiffers, OnInit, OnDestroy, ViewContainerRef, Output, DoCheck } from '@angular/core';\n\n@Directive({\n    selector: '[ngGridItem]',\n    inputs: ['config: ngGridItem']\n})\nexport class NgGridItem implements OnInit, OnDestroy, DoCheck {\n    // Event Emitters\n    @Output() public onItemChange: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>(false);\n    @Output() public onDragStart: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onDrag: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onDragStop: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onDragAny: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onResizeStart: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onResize: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onResizeStop: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onResizeAny: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onChangeStart: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onChange: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onChangeStop: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public onChangeAny: EventEmitter<NgGridItemEvent> = new EventEmitter<NgGridItemEvent>();\n    @Output() public ngGridItemChange: EventEmitter<NgGridItemConfig> = new EventEmitter<NgGridItemConfig>();\n\n    // Default config\n    private static CONST_DEFAULT_CONFIG: NgGridItemConfig = {\n        uid: null,\n        col: 1,\n        row: 1,\n        sizex: 1,\n        sizey: 1,\n        dragHandle: null,\n        resizeHandle: null,\n        fixed: false,\n        draggable: true,\n        resizable: true,\n        borderSize: 25,\n        resizeDirections: null,\n    };\n\n    public isFixed: boolean = false;\n    public isDraggable: boolean = true;\n    public isResizable: boolean = true;\n    public minWidth: number = 0;\n    public minHeight: number = 0;\n    public uid: string = null;\n\n    // Private variables\n    private _payload: any;\n    private _currentPosition: NgGridItemPosition = { col: 1, row: 1 };\n    private _size: NgGridItemSize = { x: 1, y: 1 };\n    private _config = NgGridItem.CONST_DEFAULT_CONFIG;\n    private _userConfig = null;\n    private _dragHandle: string;\n    private _resizeHandle: ResizeHandle;\n    private _borderSize: number;\n    private _elemWidth: number;\n    private _elemHeight: number;\n    private _elemLeft: number;\n    private _elemTop: number;\n    private _added: boolean = false;\n    private _differ: KeyValueDiffer<string, any>;\n    private _cascadeMode: string;\n    private _maxCols: number = 0;\n    private _minCols: number = 0;\n    private _maxRows: number = 0;\n    private _minRows: number = 0;\n    private _resizeDirections: string[] = [];\n    private _zIndex: number = 0;\n\n    set zIndex(zIndex: number) {\n        this._renderer.setStyle(this._ngEl.nativeElement, 'z-index', zIndex.toString());\n        this._zIndex = zIndex;\n    }\n\n    get zIndex(): number {\n        return this._zIndex;\n    }\n\n    // [ng-grid-item] handler\n    set config(v: NgGridItemConfig) {\n        this._userConfig = v;\n\n        const configObject = Object.assign({}, NgGridItem.CONST_DEFAULT_CONFIG, v);\n        for (let x in NgGridItem.CONST_DEFAULT_CONFIG)\n            if (configObject[x] == null)\n                configObject[x] = NgGridItem.CONST_DEFAULT_CONFIG[x];\n\n        this.setConfig(configObject);\n\n        if (this._userConfig != null) {\n            if (this._differ == null) {\n                this._differ = this._differs.find(this._userConfig).create();\n            }\n\n            this._differ.diff(this._userConfig);\n        }\n\n        if (!this._added) {\n            this._added = true;\n            this._ngGrid.addItem(this);\n        }\n\n        this._recalculateDimensions();\n        this._recalculatePosition();\n    }\n\n    get sizex(): number {\n        return this._size.x;\n    }\n\n    get sizey(): number {\n        return this._size.y;\n    }\n\n    get col(): number {\n        return this._currentPosition.col;\n    }\n\n    get row(): number {\n        return this._currentPosition.row;\n    }\n\n    get currentCol(): number {\n        return this._currentPosition.col;\n    }\n\n    get currentRow(): number {\n        return this._currentPosition.row;\n    }\n\n    // Constructor\n    constructor(\n        private _differs: KeyValueDiffers,\n        private _ngEl: ElementRef,\n        private _renderer: Renderer2,\n        private _ngGrid: NgGrid,\n        public containerRef: ViewContainerRef,\n    ) { }\n\n    public onResizeStartEvent(): void {\n        const event: NgGridItemEvent = this.getEventOutput();\n        this.onResizeStart.emit(event);\n        this.onResizeAny.emit(event);\n        this.onChangeStart.emit(event);\n        this.onChangeAny.emit(event);\n    }\n    public onResizeEvent(): void {\n        const event: NgGridItemEvent = this.getEventOutput();\n        this.onResize.emit(event);\n        this.onResizeAny.emit(event);\n        this.onChange.emit(event);\n        this.onChangeAny.emit(event);\n    }\n    public onResizeStopEvent(): void {\n        const event: NgGridItemEvent = this.getEventOutput();\n        this.onResizeStop.emit(event);\n        this.onResizeAny.emit(event);\n        this.onChangeStop.emit(event);\n        this.onChangeAny.emit(event);\n\n        this.onConfigChangeEvent();\n    }\n    public onDragStartEvent(): void {\n        const event: NgGridItemEvent = this.getEventOutput();\n        this.onDragStart.emit(event);\n        this.onDragAny.emit(event);\n        this.onChangeStart.emit(event);\n        this.onChangeAny.emit(event);\n    }\n    public onDragEvent(): void {\n        const event: NgGridItemEvent = this.getEventOutput();\n        this.onDrag.emit(event);\n        this.onDragAny.emit(event);\n        this.onChange.emit(event);\n        this.onChangeAny.emit(event);\n    }\n    public onDragStopEvent(): void {\n        const event: NgGridItemEvent = this.getEventOutput();\n        this.onDragStop.emit(event);\n        this.onDragAny.emit(event);\n        this.onChangeStop.emit(event);\n        this.onChangeAny.emit(event);\n\n        this.onConfigChangeEvent();\n    }\n    public onCascadeEvent(): void {\n        this.onConfigChangeEvent();\n    }\n\n    public ngOnInit(): void {\n        this._renderer.addClass(this._ngEl.nativeElement, 'grid-item');\n        if (this._ngGrid.autoStyle) this._renderer.setStyle(this._ngEl.nativeElement, 'position', 'absolute');\n        this._recalculateDimensions();\n        this._recalculatePosition();\n\n        // Force a config update in case there is no config assigned\n        this.config = this._userConfig;\n    }\n\n    // Public methods\n    public canDrag(e: any): boolean {\n        if (!this.isDraggable) return false;\n\n        if (this._dragHandle) {\n            return this.findHandle(this._dragHandle, e.target);\n        }\n\n        return true;\n    }\n\n    public findHandle(handleSelector: string, startElement: HTMLElement): boolean {\n        try {\n            let targetElem: any = startElement;\n\n            while (targetElem && targetElem != this._ngEl.nativeElement) {\n                if (this.elementMatches(targetElem, handleSelector)) return true;\n\n                targetElem = targetElem.parentElement;\n            }\n        } catch (err) {}\n\n        return false;\n    }\n\n    public canResize(e: any): string {\n        if (!this.isResizable) return null;\n\n        if (this._resizeHandle) {\n            if (typeof this._resizeHandle === 'string') {\n                return this.findHandle(this._resizeHandle, e.target) ? 'bottomright' : null;\n            }\n\n            if (typeof this._resizeHandle !== 'object') return null;\n\n            const resizeDirections = [ 'bottomright', 'bottomleft', 'topright', 'topleft', 'right', 'left', 'bottom', 'top' ];\n            for (let direction of resizeDirections) {\n                if (direction in this._resizeHandle) {\n                    if (this.findHandle(this._resizeHandle[direction], e.target)) {\n                        return direction;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        if (this._borderSize <= 0) return null;\n\n        const mousePos: NgGridRawPosition = this._getMousePosition(e);\n\n        for (let direction of this._resizeDirections) {\n            if (this.canResizeInDirection(direction, mousePos)) {\n                return direction;\n            }\n        }\n\n        return null;\n    }\n\n    public onMouseMove(e: any): void {\n        if (this._ngGrid.autoStyle) {\n            if (this._ngGrid.resizeEnable) {\n                const resizeDirection = this.canResize(e);\n\n                let cursor: string = 'default';\n                switch (resizeDirection) {\n                    case 'bottomright':\n                    case 'topleft':\n                        cursor = 'nwse-resize';\n                        break;\n                    case 'topright':\n                    case 'bottomleft':\n                        cursor = 'nesw-resize';\n                        break;\n                    case 'top':\n                    case 'bottom':\n                        cursor = 'ns-resize';\n                        break;\n                    case 'left':\n                    case 'right':\n                        cursor = 'ew-resize';\n                        break;\n                    default:\n                        if (this._ngGrid.dragEnable && this.canDrag(e)) {\n                            cursor = 'move';\n                        }\n                        break;\n                }\n\n                this._renderer.setStyle(this._ngEl.nativeElement, 'cursor', cursor);\n            } else if (this._ngGrid.dragEnable && this.canDrag(e)) {\n                this._renderer.setStyle(this._ngEl.nativeElement, 'cursor', 'move');\n            } else {\n                this._renderer.setStyle(this._ngEl.nativeElement, 'cursor', 'default');\n            }\n        }\n    }\n\n    public ngOnDestroy(): void {\n        if (this._added) this._ngGrid.removeItem(this);\n    }\n\n    //    Getters\n    public getElement(): ElementRef {\n        return this._ngEl;\n    }\n\n    public getDragHandle(): string {\n        return this._dragHandle;\n    }\n\n    public getResizeHandle(): ResizeHandle {\n        return this._resizeHandle;\n    }\n\n    public getDimensions(): NgGridItemDimensions {\n        return { 'width': this._elemWidth, 'height': this._elemHeight };\n    }\n\n    public getSize(): NgGridItemSize {\n        return this._size;\n    }\n\n    public getPosition(): NgGridRawPosition {\n        return { 'left': this._elemLeft, 'top': this._elemTop };\n    }\n\n    public getGridPosition(): NgGridItemPosition {\n        return this._currentPosition;\n    }\n\n    //    Setters\n    public setConfig(config: NgGridItemConfig): void {\n        this._config = config;\n\n        this._payload = config.payload;\n        this._currentPosition.col = config.col ? config.col : NgGridItem.CONST_DEFAULT_CONFIG.col;\n        this._currentPosition.row = config.row ? config.row : NgGridItem.CONST_DEFAULT_CONFIG.row;\n        this._size.x = config.sizex ? config.sizex : NgGridItem.CONST_DEFAULT_CONFIG.sizex;\n        this._size.y = config.sizey ? config.sizey : NgGridItem.CONST_DEFAULT_CONFIG.sizey;\n        this._dragHandle = config.dragHandle;\n        this._resizeHandle = config.resizeHandle;\n        this._borderSize = config.borderSize;\n        this.isDraggable = config.draggable ? true : false;\n        this.isResizable = config.resizable ? true : false;\n        this.isFixed = config.fixed ? true : false;\n        this._resizeDirections = config.resizeDirections || this._ngGrid.resizeDirections;\n\n        this._maxCols = !isNaN(config.maxCols) && isFinite(config.maxCols) ? config.maxCols : 0;\n        this._minCols = !isNaN(config.minCols) && isFinite(config.minCols) ? config.minCols : 0;\n        this._maxRows = !isNaN(config.maxRows) && isFinite(config.maxRows) ? config.maxRows : 0;\n        this._minRows = !isNaN(config.minRows) && isFinite(config.minRows) ? config.minRows : 0;\n\n        this.minWidth = !isNaN(config.minWidth) && isFinite(config.minWidth) ? config.minWidth : 0;\n        this.minHeight = !isNaN(config.minHeight) && isFinite(config.minHeight) ? config.minHeight : 0;\n\n        if (this._minCols > 0 && this._maxCols > 0 && this._minCols > this._maxCols) this._minCols = 0;\n        if (this._minRows > 0 && this._maxRows > 0 && this._minRows > this._maxRows) this._minRows = 0;\n\n        if (this._added) {\n            this._ngGrid.updateItem(this);\n        }\n\n        this._size = this.fixResize(this._size);\n\n        this._recalculatePosition();\n        this._recalculateDimensions();\n    }\n\n    public ngDoCheck(): boolean {\n        if (this._differ != null) {\n            const changes: any = this._differ.diff(this._userConfig);\n\n            if (changes != null) {\n                return this._applyChanges(changes);\n            }\n        }\n\n        return false;\n    }\n\n    public setSize(newSize: NgGridItemSize, update: boolean = true): void {\n        newSize = this.fixResize(newSize);\n        this._size = newSize;\n        if (update) this._recalculateDimensions();\n\n        this.onItemChange.emit(this.getEventOutput());\n    }\n\n    public setGridPosition(gridPosition: NgGridItemPosition, update: boolean = true): void {\n        this._currentPosition = gridPosition;\n        if (update) this._recalculatePosition();\n\n        this.onItemChange.emit(this.getEventOutput());\n    }\n\n    public getEventOutput(): NgGridItemEvent {\n        return <NgGridItemEvent>{\n            uid: this.uid,\n            payload: this._payload,\n            col: this._currentPosition.col,\n            row: this._currentPosition.row,\n            sizex: this._size.x,\n            sizey: this._size.y,\n            width: this._elemWidth,\n            height: this._elemHeight,\n            left: this._elemLeft,\n            top: this._elemTop\n        };\n    }\n\n    public setPosition(x: number, y: number): void {\n        switch (this._cascadeMode) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setStyle(this._ngEl.nativeElement, 'left', x + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'top', y + 'px');\n                break;\n            case 'right':\n                this._renderer.setStyle(this._ngEl.nativeElement, 'right', x + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'top', y + 'px');\n                break;\n            case 'down':\n                this._renderer.setStyle(this._ngEl.nativeElement, 'left', x + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'bottom', y + 'px');\n                break;\n        }\n\n        this._elemLeft = x;\n        this._elemTop = y;\n    }\n\n    public setCascadeMode(cascade: string): void {\n        this._cascadeMode = cascade;\n        switch (cascade) {\n            case 'up':\n            case 'left':\n            default:\n                this._renderer.setStyle(this._ngEl.nativeElement, 'left', this._elemLeft + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'top', this._elemTop + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'right':\n                this._renderer.setStyle(this._ngEl.nativeElement, 'right', this._elemLeft + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'top', this._elemTop + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'left', null);\n                this._renderer.setStyle(this._ngEl.nativeElement, 'bottom', null);\n                break;\n            case 'down':\n                this._renderer.setStyle(this._ngEl.nativeElement, 'left', this._elemLeft + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'bottom', this._elemTop + 'px');\n                this._renderer.setStyle(this._ngEl.nativeElement, 'right', null);\n                this._renderer.setStyle(this._ngEl.nativeElement, 'top', null);\n                break;\n        }\n    }\n\n    public setDimensions(w: number, h: number): void {\n        if (w < this.minWidth) w = this.minWidth;\n        if (h < this.minHeight) h = this.minHeight;\n\n        this._renderer.setStyle(this._ngEl.nativeElement, 'width', w + 'px');\n        this._renderer.setStyle(this._ngEl.nativeElement, 'height', h + 'px');\n\n        this._elemWidth = w;\n        this._elemHeight = h;\n    }\n\n    public startMoving(): void {\n        this._renderer.addClass(this._ngEl.nativeElement, 'moving');\n        const style: any = window.getComputedStyle(this._ngEl.nativeElement);\n        if (this._ngGrid.autoStyle) this._renderer.setStyle(this._ngEl.nativeElement, 'z-index', (parseInt(style.getPropertyValue('z-index')) + 1).toString());\n    }\n\n    public stopMoving(): void {\n        this._renderer.removeClass(this._ngEl.nativeElement, 'moving');\n        const style: any = window.getComputedStyle(this._ngEl.nativeElement);\n        if (this._ngGrid.autoStyle) this._renderer.setStyle(this._ngEl.nativeElement, 'z-index', (parseInt(style.getPropertyValue('z-index')) - 1).toString());\n    }\n\n    public recalculateSelf(): void {\n        this._recalculatePosition();\n        this._recalculateDimensions();\n    }\n\n    public fixResize(newSize: NgGridItemSize): NgGridItemSize {\n        if (this._maxCols > 0 && newSize.x > this._maxCols) newSize.x = this._maxCols;\n        if (this._maxRows > 0 && newSize.y > this._maxRows) newSize.y = this._maxRows;\n\n        if (this._minCols > 0 && newSize.x < this._minCols) newSize.x = this._minCols;\n        if (this._minRows > 0 && newSize.y < this._minRows) newSize.y = this._minRows;\n\n        const itemWidth = (newSize.x * this._ngGrid.colWidth) + ((this._ngGrid.marginLeft + this._ngGrid.marginRight) * (newSize.x - 1));\n        if (itemWidth < this.minWidth) newSize.x = Math.ceil((this.minWidth + this._ngGrid.marginRight + this._ngGrid.marginLeft) / (this._ngGrid.colWidth + this._ngGrid.marginRight + this._ngGrid.marginLeft));\n\n        const itemHeight = (newSize.y * this._ngGrid.rowHeight) + ((this._ngGrid.marginTop + this._ngGrid.marginBottom) * (newSize.y - 1));\n        if (itemHeight < this.minHeight) newSize.y = Math.ceil((this.minHeight + this._ngGrid.marginBottom + this._ngGrid.marginTop) / (this._ngGrid.rowHeight + this._ngGrid.marginBottom + this._ngGrid.marginTop));\n\n        return newSize;\n    }\n\n    // Private methods\n    private elementMatches(element: any, selector: string): boolean {\n        if (!element) return false;\n        if (element.matches) return element.matches(selector);\n        if (element.oMatchesSelector) return element.oMatchesSelector(selector);\n        if (element.msMatchesSelector) return element.msMatchesSelector(selector);\n        if (element.mozMatchesSelector) return element.mozMatchesSelector(selector);\n        if (element.webkitMatchesSelector) return element.webkitMatchesSelector(selector);\n\n        if (!element.document || !element.ownerDocument) return false;\n\n        const matches: any = (element.document || element.ownerDocument).querySelectorAll(selector);\n        let i: number = matches.length;\n        while (--i >= 0 && matches.item(i) !== element) { }\n        return i > -1;\n    }\n\n    private _recalculatePosition(): void {\n        const x: number = (this._ngGrid.colWidth + this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._currentPosition.col - 1) + this._ngGrid.marginLeft + this._ngGrid.screenMargin;\n        const y: number = (this._ngGrid.rowHeight + this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._currentPosition.row - 1) + this._ngGrid.marginTop;\n\n        this.setPosition(x, y);\n    }\n\n    private _recalculateDimensions(): void {\n        if (this._size.x < this._ngGrid.minCols) this._size.x = this._ngGrid.minCols;\n        if (this._size.y < this._ngGrid.minRows) this._size.y = this._ngGrid.minRows;\n\n        const newWidth: number = (this._ngGrid.colWidth * this._size.x) + ((this._ngGrid.marginLeft + this._ngGrid.marginRight) * (this._size.x - 1));\n        const newHeight: number = (this._ngGrid.rowHeight * this._size.y) + ((this._ngGrid.marginTop + this._ngGrid.marginBottom) * (this._size.y - 1));\n\n        const w: number = Math.max(this.minWidth, this._ngGrid.minWidth, newWidth);\n        const h: number = Math.max(this.minHeight, this._ngGrid.minHeight, newHeight);\n\n        this.setDimensions(w, h);\n    }\n\n    private _getMousePosition(e: any): NgGridRawPosition {\n        if (e.originalEvent && e.originalEvent.touches) {\n            const oe: any = e.originalEvent;\n            e = oe.touches.length ? oe.touches[0] : (oe.changedTouches.length ? oe.changedTouches[0] : e);\n        } else if (e.touches) {\n            e = e.touches.length ? e.touches[0] : (e.changedTouches.length ? e.changedTouches[0] : e);\n        }\n\n\n        const refPos: NgGridRawPosition = this._ngEl.nativeElement.getBoundingClientRect();\n\n        return {\n            left: e.clientX - refPos.left,\n            top: e.clientY - refPos.top\n        };\n    }\n\n    private _applyChanges(changes: any): boolean {\n        let changed: boolean = false;\n        const changeCheck = (record: any) => {\n            if (this._config[record.key] !== record.currentValue) {\n                this._config[record.key] = record.currentValue;\n                changed = true;\n            }\n        };\n        changes.forEachAddedItem(changeCheck);\n        changes.forEachChangedItem(changeCheck);\n        changes.forEachRemovedItem((record: any) => {\n            changed = true;\n            delete this._config[record.key];\n        });\n\n        if (changed) {\n            this.setConfig(this._config);\n        }\n\n        return changed;\n    }\n\n    private onConfigChangeEvent() {\n        if (this._userConfig === null) return;\n\n        this._config.sizex = this._userConfig.sizex = this._size.x;\n        this._config.sizey = this._userConfig.sizey = this._size.y;\n        this._config.col = this._userConfig.col = this._currentPosition.col;\n        this._config.row = this._userConfig.row = this._currentPosition.row;\n        this.ngGridItemChange.emit(this._userConfig);\n    }\n\n    private canResizeInDirection(direction: string, mousePos: NgGridRawPosition): boolean {\n        switch (direction) {\n            case 'bottomright':\n                return mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize\n                    && mousePos.top < this._elemHeight && mousePos.top > this._elemHeight - this._borderSize; // tslint:disable-line:indent\n            case 'bottomleft':\n                return mousePos.left < this._borderSize && mousePos.top < this._elemHeight\n                    && mousePos.top > this._elemHeight - this._borderSize; // tslint:disable-line:indent\n            case 'topright':\n                return mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize\n                    && mousePos.top < this._borderSize; // tslint:disable-line:indent\n            case 'topleft':\n                return mousePos.left < this._borderSize && mousePos.top < this._borderSize;\n            case 'right':\n                return mousePos.left < this._elemWidth && mousePos.left > this._elemWidth - this._borderSize;\n            case 'left':\n                return mousePos.left < this._borderSize;\n            case 'bottom':\n                return mousePos.top < this._elemHeight && mousePos.top > this._elemHeight - this._borderSize;\n            case 'top':\n                return mousePos.top < this._borderSize;\n            default:\n                return false;\n        }\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { NgGrid } from '../directives/NgGrid';\nimport { NgGridItem } from '../directives/NgGridItem';\nimport { NgGridPlaceholder } from '../components/NgGridPlaceholder';\n\n@NgModule({\n  declarations:     [ NgGrid, NgGridItem, NgGridPlaceholder ],\n  entryComponents:  [ NgGridPlaceholder ],\n  exports:          [ NgGrid, NgGridItem ]\n})\nexport class NgGridModule {}\n"]}